核心还是面对接口编程

# client/bc/api

## 接口：

```java
/*
	这个接口非常特殊，因为只有这个接口的实现类使用了@Named注解，其他接口的实现类全部没有，通过观察这些下面的这些方法的名称和返回值可以清晰的看到，这个接口的实现类就是为我们准备好这些对应类型的对象的。让我们去看一看它的实现类吧
*/
public interface BcClientService {
    BcRabbitMqJsonRpcSender getRabbitMqSender();
    EventBus getBcEventBus();
    OplogService getOplogService();
    UsedCountService getUsedCountService();
    AdminService getAdminService();
    AdminMenuService getAdminMenuService();
}
```

## 实现类：

```java
@Named
public class BcClientServiceImpl implements BcClientService {
    @Inject
    private BcRabbitMqJsonRpcSender bcRabbitMqJsonRpcSender;

    private EventBus bcEventBus = null;

    private OplogService oplogService = new OplogServiceImpl(this);

    private UsedCountService usedCountService = new UsedCountServiceImpl(this);

    private AdminService adminService = new AdminServiceImpl(this);

    private AdminMenuService adminMenuService = new AdminMenuServiceImpl(this);

    @Override
    public BcRabbitMqJsonRpcSender getRabbitMqSender() {
        return this.bcRabbitMqJsonRpcSender;
    }

    @Override
    public EventBus getBcEventBus() {
        if (bcEventBus == null) {
            synchronized (this) {
                if (bcEventBus == null) {
                    bcEventBus = EventBusManager.getInstance().getEventBus("bcEventBus", 2);
                    bcEventBus.addListener(new BcEventImpl(this));
                }
            }
        }
        return this.bcEventBus;
    }

    @Override
    public OplogService getOplogService() {
        return this.oplogService;
    }

    @Override
    public UsedCountService getUsedCountService() {
        return this.usedCountService;
    }

    @Override
    public AdminService getAdminService() {
        return this.adminService;
    }

    @Override
    public AdminMenuService getAdminMenuService() {
        return this.adminMenuService;
    }

}
```

## 总结：

​	上面那个是中央接口，这个中央接口的实现类里面会依赖其他接口的实现类。然后会在这里为其他接口的实现类做初始化。同时因为实现了中央接口，所以提供了getXXX方法。通过这些getXXX方法久可以拿到这些已经初始化的对象。

​	而其他接口的实现类又会依赖于这个中央接口的实现类。这不就是一种循环依赖吗。然后神奇的是这里竟然是可以这样工作的！

​	至于为什么要这样做呢？这样做的好处就是其他接口的实现类里面可以通过这个中央接口的实现类的getXXX方法拿到其他所有的接口！！！这样的话，这些其余接口之间就可以互相使用所有接口的服务了！真的是非常秀！

