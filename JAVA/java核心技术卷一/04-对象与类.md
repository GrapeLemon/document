---
typora-root-url: images
---

# 1.面向对象程序设计概述

## 	

## 	类：

​		类是构造对象的模板或蓝图。

​		由类构造（construct）对象的过程称为创建类的实例(instance)。	

​		在java中编写的所有代码都位于某个类的内部。

​		封装(encapsulation,有时称为数据隐藏)

​			实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。

这里有句话就看不懂了：这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据。其他对象就不会知道或介意所发生的变化。

## 	对象：

要想使用OOP，一定要清楚对象的三个主要特性：

​	@对象的行为（behavior）：可以对对象施加哪些操作，或可以对对象施加哪些方法？

​	@对象的状态  (state) ：当施加那些方法时，对象如何响应？

​	@对象标识 (identity) ： 如何辨别具有相同行为与状态的不同对象？

同一个类的所有实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。

此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随时时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。（如果不经过方法调用就可以改变对象状态，说明封装性遭到了破坏）

但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份（identity）。

@@ 所以说，靠句柄来识别对象是很不可可靠的，现在大量使用的东西叫匿名对象，这些家伙都是无名氏，那我们怎样标识这些东西呢？用的好像就是hashcode?

@@应该不能简单的这样说，反正识别对象靠@xxxx就行了，这个是不可能重复的，来标识唯一的一个对象。

## 识别类：

​	经验之谈，名词作为属性，动词作为方法。

## 

## 类之间的关系：

### 依赖

### 聚合

### 继承	

难点在于？依赖和聚合的区别是什么？

​	如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。

​	而聚合关系意味着类A的对象包含类B的对象。

但是我们经常都可以在代码中看到我们对一个类可能又是依赖又是聚合的。一个类里面放了其他类型的句柄，然后通过注入实例化。然后又在这个类的方法里面用了其他类型的方法，这不就是又是依赖又是聚合了吗？所以这两个概念是可能会重合的，而不是完全没有交集的，之前的理解不够深，没有到这个点。

通常来说单纯聚合的情况很少，绝大多数是以下这两种情况：

​	依赖：没有作为成员，但是在方法中需要用到这种类型的参数，称之为依赖。一种单纯的依赖这种类型。

​	依赖+聚合：作为成员而且还在方法中用了，这就是最常见的情况了。



# 2. 使用预定义类

​	在java中，没有类就无法做任何事情。

​	然而，并不是所有的类都具有面向对象特征。

​	例如	Math类竟然全部都是静态方法！而且也没有实例域(但是有静态常量 static final )！我感觉工具类应该都是这种设计方法吧.

​	**所有的java对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针**。

## 		Java类库中的LocalDate类

​			时间是用距离一个固定时间点的毫秒数(可正可负)表示的，这个点就是所谓的纪元(epoch)

​			纪元是UTC时间 1970年1月1日 00:00:00

​			UTC： Coordinated Universal Time的缩写

​			GMT：Greenwich Mean Time 格林威治时间

​		上面着两种时间都是一种具有实践意义的科学标准时间

Date类：用来表示时间点

LocalDate类：用来表示大家熟悉的日历表示法的类。



# 	用户自定义类

​		重点：如何设计复杂应用程序所需要的各种主力类(workhorse class),通常，这些类没有main方法，却有自己的实例域和实例方法

​		一个完整的程序应该是将若干类组合在一起，其中只有一个类有main方法.

​	话说 unix的 “make”工具到底是拿来干嘛的，我发现经常有用到，但是不知道是什么来的

## 		隐式参数与显示参数

​	隐式参数也就是所谓的this，我看有一种用法是把this当参数传递进去。我突然又联想到订阅者模式了，通过xxx(this)这种方法就可以把订阅者加进去了！

​	显示参数就不多说了，经常都会用的东西。传基本类型还好，基本就是直接用，如果传类型进行就复杂了，分分钟各种调用烦死人。

## 封装的优点

​	封装我们经常都干（也就是所谓的把实例域定义为私有，然后写上公有的get set方法)，但是这样做到底有什么好处呢？

​	1.首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。例如，如果将存储名字的域改为：

​	

```java
String firstName;
String last Name
//那么getName方法可以改为返回
firstName + " " + lastName  
```



对于这点改变，程序的其他部分完全不可见

​	@@但是奇怪的是，你setName的方法不是要改变吗 所以也并没有完全消除影响。

2. 当然，为了进行新旧数据表示之间的转换，get方法和set方法有可能需要做许多工作。但是，这将为我们带来第二个好处：set方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。

   例如，setSalary方法可以检查薪金是否小于0.

   ​	@@一开始我想这样反驳：那我在执行set方法前检查一下不就好了。效果一样啊！但是紧接着我有考虑到：假设这set方法被执行的次数超过一次，那么它这样设计就有优势，**假设被执行很多次，那这样设计的价值就很大了**。



### 警告：

​	注意不要编写返回引用可变对象的get方法。在Employee类中就违反了这个设计原则，其中的getHireDay 方法返回了一个Date类对象：

```java
class Employee{
    private Date hireDay;
    public Date getHireDay(){
        return hireDay; //Bad
	}
}
```

LocalDate没有set方法，但是Date类有一个set方法setTime(),可以在这里设置毫秒数

Date对象是可变的，这一点就破坏了封装性！

```java
Employee harry = . .
Date d = harry.getHireDay();
double tenYearsInMilliSeconds = 10 * 365.25 * 24 * 60 * 60 * 1000;
d.setTime(d.getTime() - (long) tenYearsInMilliSeconds) ;
// let's give Harry ten years of added seniority
```

出错的原因很微妙，d 和 garry.hireDay引用同一个对象。对 d 调用set方法就可以自动地改变这个雇员对象的私有状态。

![返回可变数据域的引用](/返回可变数据域的引用.png)

如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone）.@@**我觉得应该是说，如果需要返回一个可变对象的拷贝，也就是不希望修改原有的对象**@@。对象**clone是指存放在另一个位置上的对象副本**。



```java
class Employee{
    public Date getHireDay(){
        return (Date)hireDay.clone();	//ok
    }
}
```



凭经验可知，如果需要返回一个可变数据域的拷贝，就应该使用clone.