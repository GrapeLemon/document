![1564807014781](D:\我的文档\JAVA\框架\Spring解密\images\IOC服务提供者的糟糕实现)

这段代码就可以任务是这个场景中的IoC Service Provider，只不过比较简单，而且目的也过于单一罢了。要将系统中几十、几百甚至数以千计的业务对象绑定到一起，采用这种方式显然是不切实际的。通用性暂且不谈，单单写这些绑定代码也会是一种很糟糕的体验。



# IoC service Provider的职责

## 业务对象的构建管理

​	在IoC场景中，业务对象无需关系所依赖的对象如何构建如何取得，但这部分工作始终需要有人来做。**所以，IoC Service Provider 需要将对象的构建逻辑从客户端对象那里剥离出来，以免这部分逻辑污染业务对象的实现。**

## 业务对象间的依赖绑定

​	对于IoC Service Provider来说，这个职责是最艰巨也是最重要的，这说它的最终使命之所在。如果不能完成这个职责，那么，无论业务对象如何的“呼喊”，也不会得到依赖对象的任何响应。IoC Service Provider 通过结合之前构建和管理的所有业务对象，以及各个业务对象间可以识别的依赖关系，将这些对象所依赖的对象注入绑定，从而保证每个业务对象在使用的时候，可以处于就绪状态。

# 运筹帷幄的秘密——IoC Service Provider 如何管理对象间的依赖关系

​	前面我们说过，被注入对象可以通过多种方式通知IoC Service Provider为其注入相应依赖，但问题在于，收到通知的IoC Service Provider 是否就一定能够完全领会被注入对象的意图，并及时有效地为其提供想要的依赖呢？**有些时候，事情可能并非像我们所想象的那样理所当然**

ISP需要有记录诸多对象之间对应关系的内容来为我们提供服务。

1. 用文本文件来记录被注入对象和其依赖对象之间的对应关系。
2. 也可以通过描述性较强的XML文件格式来记录对应信息。
3. 还可以通过编写代码的方式来注册这些对应信息。



## 直接编码方式

![1564808313571](D:\我的文档\JAVA\框架\Spring解密\images\直接编码方式)

当前大部分的IoC容器应该支持直接编码方式，例如Spring。在容器启动之前，我们就可以通过程序编码的方式将被注入对象和依赖对象注册到容器中，并明确它们相互之间的依赖注入关系。通过为相应的类指定对应的具体实例，可以告知IoC容器，当我们要这种类型的对象实例时，请将容器中注册的、对应的那个具体实例返回给我们。

所以，通过程序编码让最终的IoC Service Provider(也就是各个IoC框架或者容器实现)得以知晓服务的奥义，应该是管理依赖绑定关系的最基本方式。



## 配置文件方式

这是一种较为普遍的依赖注入关系管理方式。这里主要讲XML文件的方式，因为Spring以前基本都是用XML文件的。

![1564811035836](D:\我的文档\JAVA\框架\Spring解密\images\spring使用xml文件来配置)

最后，我们就可以像上图所示的那样，通过"newProvider" 这个名字，从容器中取得以及组装好的 FXNewsProvider并直接使用。



![1564811214547](D:\我的文档\JAVA\框架\Spring解密\images\从容器中拿出bean并使用)



## 元数据方式

​	这种方式的代表实现是Google Guice,这是 Bob Lee在Java 5的 注解和 Generic的基础上开发的一条IoC框架。我们可以直接在类中使用元数据信息（应该就是指在源代码上吧）来标注各个对象之间的依赖关系，然后由Guice框架根据这些注解所提供的信息将这些对象组装后，交给客户端对象使用。

![1564811470658](D:\我的文档\JAVA\框架\Spring解密\images\使用注解的方式来完成注册)

**通过@Inject，我们指明需要IoC Service Provider 通过构造方法注入方式，为 FXNewsProvider注入其所依赖的对象，至于余下的依赖相关信息，在Guice中是由相应的Module来提供的**。

![1564811655707](D:\我的文档\JAVA\框架\Spring解密\images\Module实现)

当然，注解最终也需要同各国代码处理来确定最终的注入关系，从这点来说，注解方式可以算作编码方式的一种特殊情况。（然后再spring boot中 使用了注解还需要用编码吗）

