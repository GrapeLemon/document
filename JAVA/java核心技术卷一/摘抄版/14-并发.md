# 引言：

​	读者可能已经很熟悉操作系统中的多任务(multitasking): 在同一刻运行多个程序的能力。例如，在编辑或者下载邮件的**同时**可以打印文件。今天，人们很可能有单台拥有多个CPU的计算机。但是，并发执行的进程数目并不是由CPU数目制约的。（也就是说，并不是说都多少个CPU就只能并发执行多少个进程的意思）操作系统将CPU的时间片分配给每一个进程，给人并行处理的感觉。

​	多线程在较低的层次上拓展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务(Task)称为一个线程(thread)，它是线程控制的简称。	可以同时运行一个以上线程的程序称为多线程程序。(multithreaded)，很显然，服务器程序基本都是多线程程序，所以多线程对于服务器开发来说非常重要。

​	那么，多进程和多线程有哪些区别呢？本质的区别在于每个进程都拥有自己的一整套变量，而线程则共享数据！这种行为是有风险的。然而，共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在有些操作系统中，与进程相比较，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小的多。

​	在实际应用中，多线程非常有用。例如，一个浏览器可以同时下载几幅图片。一个Web服务器需要同时处理几个并发的请求。图形用户界面(GUI)程序用一个独立的线程从宿主操作系统环境中搜集用户界面的事件。本章将介绍如何为Java应用程序变价多线程能力。

# 1.什么是线程？

## 	sleep

​	调用	 Thread.sleep不会创建一个新线程，sleep是Thread类的静态方法，用于暂停当前线程的活动。

​	sleep方法可以抛出一个	IntermptedException 异常。



## 	使用线程给其他任务提供机会

​		如果需要执行一个比较耗时的任务(统计，IO这些什么的，应当并发地运行任务。

​		下面是在一个单独的线程中执行一个任务的简单过程：

​		将任务代码移到实现了Runnable接口的类的run方法中。这个接口非常简单。只有一个方法(函数式接口)

​	

```java
public interface Runnable{
    void run();
}
```

由于Runnable是一个函数式接口，可以用lambda比倒是建立一个实例：

```java
Runnable r = () -> {task code};
```

由Runnable创建一个Thread对象

```java
Thread t = new Thread(r);
```

启动线程:

```java
t.start();
```

不过，这种方法已不在推荐。应该将要并行运行的任务与运行机制解耦合。如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用**线程池**来解决这个问题。

### !!警告!!

​	不要调用Thread类或Runnable对象的run方法。（感觉我好像经常就这样...有点想当然了）直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。（这句话是什么意思？？看不懂）应该调用Thread.start方法，这个方法将创建一个执行run方法的新线程。

懂了，也就是说直接调用run就好像方法调用，还是当前线程在干活，那也就没有用到多线程了。



# 2.中断线程

​	当线程的run方法执行方法体中最后一条语句后，并经由执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。

​	在java的早期版本中，还有一个stop方法，其他线程可以调用它终止。在java的早期版本中，还有一个stop方法，其他线程可以调用它终止线程。但是，这个方法已经被弃用了。后面将讨论为何弃用。

​	没有可以强制线程终止的方法。然而，interrupt方法可以用来请求终止线程。

​	当对一个线程调用interrupt方法时，线程的中断状态将被修改。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断（注意和终止的区别）。

​	要想弄清楚中断状态的的情况，首先调用静态的 Thread.currentThread方法获得当前线程，然后调用

isInterrupted方法：

​	

```
while (!Thread.currentThread().islnterrupted() && more work to do)
{
do more work
}
```

但是，如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方。当在一个被阻塞的线程（调用sleep或者wait）上调用interrupt方法时，阻塞调用将会被Interrupted Exception 异常中断 。存在不能被中断的阻塞 I/O 调用， 应该考虑选择可中断的调用。有关细节请参看卷 n 的第 1 章和第 3 章。）

​	没有任何语言 方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。但是，更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程的run方法具有如下形式:

```java
Runnable r = () -> {
try
{
	while (!Thread.currentThread().islnterrupted() && more work to do)
	{
		do more work
	}
}
catch(InterruptedException e)
{
// thread was interrupted during sleep or wait
}
finally
{
	cleanup, if required
}
// exiting the run method terminates the thread 因为执行完了！！
}；
```

如果在每次工作迭代之后都调用sleep方法(或者其他的可中断方法)，isInterrupted检测既没有必要也没有用处。如果在中断状态被修改时调用sleep方法，它不会休眠。相反，它将清除这一状态(!)并抛出IntemiptedException 。因此，如果难点循环调用sleep，不会检测中断状态。相反，要如下所示捕获 InterruptedException 异常： 

```java
Runnable r = 0 -> {
try
{
	while { more work to do)
	{
		do more work
		Thread,sleep(delay);
	}
}
catch(InterruptedException e)
{
	// thread was interrupted during sleep
}
finally
{
	cleanup,if required
}
	// exiting the run method terminates the thread
}；
```

@@注释@@​	

有两个非常类似的方法，interrupted 和 islnterrupted。Interrupted 方法 是一个静态方法，它检测当前的线程是否被中断。而且，调用interrupted 方法会清除改线程的中断状态。另一方面，islnterrupted是一个实例方法。可用来检测是否有线程被中断。调用这个方法不会改变中断状态。



@@在很多发布的代码中会发现InterruptedException 异常被抑制在很低的层次，像这样:

```java
void mySubTaskO
{
try { sleep(delay); }
catch (InterruptedException e) {} // Don't ignore!
}
```

不要这样做！如果不认为在catch子句中做这一处理有什么好处的话，仍然有两种合理的选择：

​	在catch子句中调用Thread.currentThread().interrupt()  来设置中断状态。于是，调用者可以对其进行检测。

```java
void mySubTaskO
{
	try { sleep(delay); }
	catch (InterruptedException e) { Thread.currentThread().interrupt(); }
}
```

或者，更好的选择是，用throws InterruptedException标记你的方法，不采用 try语句块捕获异常。于是，调用者(或者，最终的run方法)可以捕获这一异常。

​	这个调用者就有点诡异了。 就是从哪个方法里面写了调用这些方法，就称之为调用者吧，有点绕。

```java
void mySubTask() throws InterruptedException{
    ...
    sleep(delay);
    ...
}
```

```java
void interrupt()
//向线程发送中断请求。线程的中断状态将被设置为true。如果目前该线程被一个sleep调用阻塞，那么InterruptedException异常被抛出
    
static boolean interrupted()
//测试当前线程(即正在执行这一命令的线程)是否被中断。注意，这是一个静态方法。这一调用回产生副作用————它将当前线程的中断状态重置为false
    
static Thread currentThread()
//返回代表当前执行线程的Thread对象。
```

# 3.线程状态（核心点）

​	要确定一个线程的当前状态，可调用getState方法。

​	线程可以有如下6种状态：

## 	New(新创建)

​		当用new操作符创建一个新线程时，如 new Thread(r)，该线程还没有开始运行。这意味着它的状态是new。当一个线程处于新创建状态时，**程序还没有开始运行线程中的代码*。*在线程运行之前还有一些基础工作要做。

## 	Runnable(可运行)

​	**一旦调用start方法*，线程处于runnable状态*。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。（Java的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行的状态）

​	也就是说，**正在运行和可以运行但没有运行** 都归类在这种	Runnable状态。

​	一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。

​	**所以说，我们使用的这种多线程，并没有达到真正意义的并行，这里面涉及到操作系统的调度，他在各个线程之间来回切换，给了用户一种虚假并行的错觉，但是对于程序设计人员来说，必须清醒的认识到发生的事情：操作系统系统在各个线程之间来回切换。所以只是一个时间段从原来只给主线程跑，大家都可以跑，而不会让主线程独占全部资源**

​	所以如果是核心就是“资源分配的问题”，也就是我们写的程序，要怎样将有限的计算机资源最大化的利用。

​	现在所有的桌面以及服务器操作系统都使用抢占式调度。但是，像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用yield方法，或者被阻塞或等待时，线程才失去控制权。

​	**在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目**，调度器依然采用时间片机制。

​	记住，在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行。

## 	Blocked(被阻塞)

## 	Waiting(等待)

​	当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源（意思是说还是要占用一些资源的）。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

​	当一个线程试图获取一个内部的对象锁（而不是java.util.concurrent库中的锁 ),而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。

​	当线程等待另一个线程通知调度器一个条件时，它自己进入 等待状态。（是不是意思是说这个线程已经准备好了？）在调用 Obejct.wait方法或 Thread.join方法，或者是等待java.util.concurrent库中的Lock 或 Condition时，就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。

## 	Timed	waiting(计时等待)	

​	有几个方法有一个超时参数。调用他们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有

```
Thread.sleep
Object.wait
Thread.join
Lock.tryLock
Condition.await的计时版

```



## 	Terminated(被终止)

​	线程因如下两个原因之一而被终止：

​		因为run方法正常退出而自然死亡。

​		因为一个没有捕获的异常终止了run方法而意外死亡。

！！注意！！ 不要调用stop来终止线程，已经被废弃！



## 线程状态图：

![线程状态](D:\我的文档\JAVA\java核心技术卷一\images\线程状态.png)



# 4.线程属性

​	下面将讨论线程的各种属性，其中包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。

## 	线程优先级（先略过）

​	关键：不要依赖优先级来确保程序的正确性。

​	注意：Linux的JVM会忽略优先级，所以所有的线程具有相同的优先级。（所以在程序中写优先级相关的事情没用）	

​	在应用程序中这个好像基本都碰不到，底层代码倒是有用到相关的概念。

## 守护线程

​	讲道理，书上说了一些概念，但是还是有一些问题：

​	1.什么时候必须用？为什么？	也就是不用功能都实现不了

​	2.什么时候用了会更好? 为什么？	也就是会让程序的效率更高（耗时短，空间少）



## 未捕获异常处理器

​	线程的run方法不能抛出任何受查异常，但是，非受查异常会导致线程终止。在这种情况下，**线程就死亡了**。

​	但是，不需要任何catch来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

​	该处理器必须属于一个实现Thread.UncaughtExceptionHandler  接口的类。这个接口只有一个方法。（**实现了这个接口就叫做处理器了，好像很多框架也有这种类似的模式，我想问实现的原理是什么？看来要从设计模式那里去找了**）

​	void uncaughtException(Thread t, Throwable e) 

​	可以用	setUncaughtExceptionHandler 方法为任何线程安装一个默认的处理器。替换处理器可以使用日志API发送未捕获异常的报告到异常文件。

​	如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。

！！注释！！

​	线程组是一个可以**统一管理**的线程集合。默认情况下，创建的所有线程属于相同线程组。但是，也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。

！！重点！！

​	

# 5.同步（非常重要）

​	同步的定性应该是一种好的情况。应该就是指竞争条件不会出现。

## 		竞争条件(race condition)

​	要注意，race condition所描述的情况不是一定会发生的，而且发生了也不一定就会产生错误！但是一旦产生了错误，结果就是非常严重的（数据有误）



### 竞争条件详解

​	假定两个线程同时执行指令

​	accounts[to] += amount;		// accounts[to]  = accounts[to] + amount;

​	问题在于这不是原子操作。该指令可能被处理如下：

1. 将 accounts[to] 加载到寄存器

  2. 增加amount

  3. 将结果写回 accounts[to]。

     现在，假定第一个线程执行步骤1 和 2，然后，它被剥夺了运行权。假定第二个线程被唤醒并修改了 accounts数组中的同一项。然后，第一个线程被唤醒并完成其第三步。

     这样，这一动作擦去了第二个线程所做的更新。于是，总金额不再正确。