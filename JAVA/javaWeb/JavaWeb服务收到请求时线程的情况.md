Java对每一次Web请求，是否都会创建一个线程去处理？

也就是说如果一个类的方法同时有1000个请求访问时，线程是如何运作的？



# 1.单线程模式

​	收到一个请求就处理，这个时候不能处理新的请求。无法并发，一个请求没有处理完服务器就阻塞，不会处理下一个请求，一般服务器不会这样实现。



# 2.收到一个请求就新开一个线程去处理任务

​	收到一个请求就新开一个线程去处理任务，主线程返回，处理处理下一个任务（例如又新开一个线程去处理请求），一般来说新建线程的任务是交给主线程去做的。

​	相对于第一个模型，它解决了主线程阻塞的问题。但是在每个新开的线程中还是阻塞的。可以想到的是频繁的开关线程很消耗资源，服务器性能很差。（接受到请求 -> 新建线程处理 -> 执行结束 -> 关闭销毁线程 ）

# 3.使用线程池

​	线程池用于管理多线程，其实服务方式类似，一个线程服务一个请求，只是说可以控制线程的数量，减少创建销毁的开销而已。当超过线程数量的时候还是要阻塞的。



# 4.基于Java NIO实现的服务器模型

​	上面说到的几种模型，都是基于BIO(阻塞IO)，而NIO是非阻塞IO(通过异步的方式吗？？？)，它是基于IO多路复用技术（例如 Reactor模式）实现，只需要一个或者少量线程，就可以处理大量请求（10W？100W??）

从性能上来说NIO实现的服务器并发性一般大于BIO。

基于NIO的网络编程框架：Netty	MINA

# 超时问题：

​	如果是要求实时响应性比较高的系统，或者采用了类似Dubbo这种SOA微服务分布式的系统，一次请求的响应时间需要进行控制，这种情况下，如果代码执行到可能发生阻塞操作的地方（例如：查询数据量比较打的表、循环多次操作Redis Cache等），往往就可能出现服务器超时的问题（Timeout Exception）,对于这种情况，可以考虑采用线程池解决这个问题。

# 解决方案：

采用线程池的话，将线程池定义为全局静态对象，在方法中使用，可以将可预见的回发生阻塞操作的代码块放入线程池进行执行，如果这样，当主线程执行到线程池部分，会执行线程池的run()方法，然后主线程会继续向下执行，直到最后返回结果，而阻塞的部分将在run() 方法中执行，不会阻塞主线程的执行，这样可以达到一个异步非阻塞的快速响应。

# 超时

​	我对超时是这样理解的：规定一个时间，如果在规定时间内没做完就认为超时。例如只给1秒给当前执行线程处理完并返回响应，如果过了1秒还没响应回去就认为是超时。



# 一些思考：

​	感觉之所以能异步的因为这些线程的任务不是直接相关的。

假设主线程的某一步需要依赖于线程池中线程的任务的执行结果，那这样搞就没有意义了。

多去查不同的例子，增强联系!

