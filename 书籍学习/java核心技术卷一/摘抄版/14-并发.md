# 引言：

​	读者可能已经很熟悉操作系统中的多任务(multitasking): 在同一刻运行多个程序的能力。例如，在编辑或者下载邮件的**同时**可以打印文件。今天，人们很可能有单台拥有多个CPU的计算机。但是，并发执行的进程数目并不是由CPU数目制约的。（也就是说，并不是说都多少个CPU就只能并发执行多少个进程的意思）操作系统将CPU的时间片分配给每一个进程，给人并行处理的感觉。

​	多线程在较低的层次上拓展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务(Task)称为一个线程(thread)，它是线程控制的简称。	可以同时运行一个以上线程的程序称为多线程程序。(multithreaded)，很显然，服务器程序基本都是多线程程序，所以多线程对于服务器开发来说非常重要。

​	那么，多进程和多线程有哪些区别呢？本质的区别在于每个进程都拥有自己的一整套变量，而线程则共享数据！这种行为是有风险的。然而，共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在有些操作系统中，与进程相比较，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小的多。

​	在实际应用中，多线程非常有用。例如，一个浏览器可以同时下载几幅图片。一个Web服务器需要同时处理几个并发的请求。图形用户界面(GUI)程序用一个独立的线程从宿主操作系统环境中搜集用户界面的事件。本章将介绍如何为Java应用程序变价多线程能力。

# 1.什么是线程？

## 	sleep

​	调用	 Thread.sleep不会创建一个新线程，sleep是Thread类的静态方法，用于暂停当前线程的活动。

​	sleep方法可以抛出一个	IntermptedException 异常。



## 	使用线程给其他任务提供机会

​		如果需要执行一个比较耗时的任务(统计，IO这些什么的，应当并发地运行任务。

​		下面是在一个单独的线程中执行一个任务的简单过程：

​		将任务代码移到实现了Runnable接口的类的run方法中。这个接口非常简单。只有一个方法(函数式接口)

​	

```java
public interface Runnable{
    void run();
}
```

由于Runnable是一个函数式接口，可以用lambda比倒是建立一个实例：

```java
Runnable r = () -> {task code};
```

由Runnable创建一个Thread对象

```java
Thread t = new Thread(r);
```

启动线程:

```java
t.start();
```

不过，这种方法已不在推荐。应该将要并行运行的任务与运行机制解耦合。如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用**线程池**来解决这个问题。(**不知道是神马意思，感觉有点设计层面的东西了**)

### !!警告!!

​	不要调用Thread类或Runnable对象的run方法。（感觉我好像经常就这样...有点想当然了）直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。（这句话是什么意思？？看不懂）应该调用Thread.start方法，这个方法将创建一个执行run方法的新线程。

懂了，也就是说直接调用run就好像方法调用，还是当前线程在干活，那也就没有用到多线程了。



# 2.中断线程

​	当线程的run方法执行方法体中最后一条语句后，并经由执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。

​	在java的早期版本中，还有一个stop方法，其他线程可以调用它终止。在java的早期版本中，还有一个stop方法，其他线程可以调用它终止线程。但是，这个方法已经被弃用了。后面将讨论为何弃用。

​	没有可以强制线程终止的方法。然而，interrupt方法可以用来请求终止线程。

​	当对一个线程调用interrupt方法时，线程的中断状态将被修改。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断（注意和终止的区别）。

​	要想弄清楚中断状态的的情况，首先调用静态的 Thread.currentThread方法获得当前线程，然后调用

isInterrupted方法：

​	

```
while (!Thread.currentThread().islnterrupted() && more work to do)
{
do more work
}
```

但是，如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方。当在一个被阻塞的线程（调用sleep或者wait）上调用interrupt方法时，阻塞调用将会被Interrupted Exception 异常中断 。存在不能被中断的阻塞 I/O 调用， 应该考虑选择可中断的调用。有关细节请参看卷 n 的第 1 章和第 3 章。）

​	没有任何语言 方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。但是，更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程的run方法具有如下形式:

```java
Runnable r = () -> {
try
{
	while (!Thread.currentThread().islnterrupted() && more work to do)
	{
		do more work
	}
}
catch(InterruptedException e)
{
// thread was interrupted during sleep or wait
}
finally
{
	cleanup, if required
}
// exiting the run method terminates the thread 因为执行完了！！
}；
```

如果在每次工作迭代之后都调用sleep方法(或者其他的可中断方法)，isInterrupted检测既没有必要也没有用处。如果在中断状态被修改时调用sleep方法，它不会休眠。相反，它将清除这一状态(!)并抛出IntemiptedException 。因此，如果难点循环调用sleep，不会检测中断状态。相反，要如下所示捕获 InterruptedException 异常： 

```java
Runnable r = 0 -> {
try
{
	while { more work to do)
	{
		do more work
		Thread,sleep(delay);
	}
}
catch(InterruptedException e)
{
	// thread was interrupted during sleep
}
finally
{
	cleanup,if required
}
	// exiting the run method terminates the thread
}；
```

@@注释@@​	

有两个非常类似的方法，interrupted 和 islnterrupted。Interrupted 方法 是一个静态方法，它检测当前的线程是否被中断。而且，调用interrupted 方法会清除改线程的中断状态。另一方面，islnterrupted是一个实例方法。可用来检测是否有线程被中断。调用这个方法不会改变中断状态。



@@在很多发布的代码中会发现InterruptedException 异常被抑制在很低的层次，像这样:

```java
void mySubTaskO
{
try { sleep(delay); }
catch (InterruptedException e) {} // Don't ignore!
}
```

不要这样做！如果不认为在catch子句中做这一处理有什么好处的话，仍然有两种合理的选择：

​	在catch子句中调用Thread.currentThread().interrupt()  来设置中断状态。于是，调用者可以对其进行检测。

```java
void mySubTaskO
{
	try { sleep(delay); }
	catch (InterruptedException e) { Thread.currentThread().interrupt(); }
}
```

或者，更好的选择是，用throws InterruptedException标记你的方法，不采用 try语句块捕获异常。于是，调用者(或者，最终的run方法)可以捕获这一异常。

​	这个调用者就有点诡异了。 就是从哪个方法里面写了调用这些方法，就称之为调用者吧，有点绕。

```java
void mySubTask() throws InterruptedException{
    ...
    sleep(delay);
    ...
}
```

```java
void interrupt()
//向线程发送中断请求。线程的中断状态将被设置为true。如果目前该线程被一个sleep调用阻塞，那么InterruptedException异常被抛出
    
static boolean interrupted()
//测试当前线程(即正在执行这一命令的线程)是否被中断。注意，这是一个静态方法。这一调用回产生副作用————它将当前线程的中断状态重置为false
    
static Thread currentThread()
//返回代表当前执行线程的Thread对象。
```

# 3.线程状态（核心点）

​	要确定一个线程的当前状态，可调用getState方法。

​	线程可以有如下6种状态：

## 	New(新创建)

​		当用new操作符创建一个新线程时，如 new Thread(r)，该线程还没有开始运行。这意味着它的状态是new。当一个线程处于新创建状态时，**程序还没有开始运行线程中的代码*。*在线程运行之前还有一些基础工作要做。

## 	Runnable(可运行)

​	**一旦调用start方法*，线程处于runnable状态*。一个可运行的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间。（Java的规范说明没有将它作为一个单独状态。一个正在运行中的线程仍然处于可运行的状态）

​	也就是说，**正在运行和可以运行但没有运行** 都归类在这种	Runnable状态。

​	一旦一个线程开始运行，它不必始终保持运行。事实上，运行中的线程被中断，目的是为了让其他线程获得运行机会。线程调度的细节依赖于操作系统提供的服务。抢占式调度系统给每一个可运行线程一个时间片来执行任务。当时间片用完，操作系统剥夺该线程的运行权，并给另一个线程运行机会。当选择下一个线程时，操作系统考虑线程的优先级。

​	**所以说，我们使用的这种多线程，并没有达到真正意义的并行，这里面涉及到操作系统的调度，他在各个线程之间来回切换，给了用户一种虚假并行的错觉，但是对于程序设计人员来说，必须清醒的认识到发生的事情：操作系统系统在各个线程之间来回切换。所以只是一个时间段从原来只给主线程跑，大家都可以跑，而不会让主线程独占全部资源**

​	所以如果是核心就是“资源分配的问题”，也就是我们写的程序，要怎样将有限的计算机资源最大化的利用。

​	现在所有的桌面以及服务器操作系统都使用抢占式调度。但是，像手机这样的小型设备可能使用协作式调度。在这样的设备中，一个线程只有在调用yield方法，或者被阻塞或等待时，线程才失去控制权。

​	**在具有多个处理器的机器上，每一个处理器运行一个线程，可以有多个线程并行运行。当然，如果线程的数目多于处理器的数目**，调度器依然采用时间片机制。

​	记住，在任何给定时刻，一个可运行的线程可能正在运行也可能没有运行。

## 	Blocked(被阻塞)

## 	Waiting(等待)

​	当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源（意思是说还是要占用一些资源的）。直到线程调度器重新激活它。细节取决于它是怎样达到非活动状态的。

​	当一个线程试图获取一个内部的对象锁（而不是java.util.concurrent库中的锁 ),而该锁被其他线程持有，则该线程进入阻塞状态。当所有其他线程释放该锁，并且线程调度器允许本线程持有它的时候，该线程将变成非阻塞状态。

​	当线程等待另一个线程通知调度器一个条件时，它自己进入 等待状态。（是不是意思是说这个线程已经准备好了？）在调用 Obejct.wait方法或 Thread.join方法，或者是等待java.util.concurrent库中的Lock 或 Condition时，就会出现这种情况。实际上，被阻塞状态与等待状态是有很大不同的。

## 	Timed	waiting(计时等待)	

​	有几个方法有一个超时参数。调用他们导致线程进入计时等待(timed waiting)状态。这一状态将一直保持到超时期满或者接收到适当的通知。带有超时参数的方法有

```
Thread.sleep
Object.wait
Thread.join
Lock.tryLock
Condition.await的计时版

```



## 	Terminated(被终止)

​	线程因如下两个原因之一而被终止：

​		因为run方法正常退出而自然死亡。

​		因为一个没有捕获的异常终止了run方法而意外死亡。

！！注意！！ 不要调用stop来终止线程，已经被废弃！



## 线程状态图：

![线程状态](D:\我的文档\JAVA\java核心技术卷一\images\线程状态.png)



# 4.线程属性

​	下面将讨论线程的各种属性，其中包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。

## 	线程优先级（先略过）

​	关键：不要依赖优先级来确保程序的正确性。

​	注意：Linux的JVM会忽略优先级，所以所有的线程具有相同的优先级。（所以在程序中写优先级相关的事情没用）	

​	在应用程序中这个好像基本都碰不到，底层代码倒是有用到相关的概念。

## 守护线程

​	讲道理，书上说了一些概念，但是还是有一些问题：

​	1.什么时候必须用？为什么？	也就是不用功能都实现不了

​	2.什么时候用了会更好? 为什么？	也就是会让程序的效率更高（耗时短，空间少）



## 未捕获异常处理器

​	线程的run方法不能抛出任何受查异常，但是，非受查异常会导致线程终止。在这种情况下，**线程就死亡了**。

​	但是，不需要任何catch来处理可以被传播的异常。相反，就在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。

​	该处理器必须属于一个实现Thread.UncaughtExceptionHandler  接口的类。这个接口只有一个方法。（**实现了这个接口就叫做处理器了，好像很多框架也有这种类似的模式，我想问实现的原理是什么？看来要从设计模式那里去找了**）

​	void uncaughtException(Thread t, Throwable e) 

​	可以用	setUncaughtExceptionHandler 方法为任何线程安装一个默认的处理器。替换处理器可以使用日志API发送未捕获异常的报告到异常文件。

​	如果不安装默认的处理器，默认的处理器为空。但是，如果不为独立的线程安装处理器，此时的处理器就是该线程的ThreadGroup对象。

！！注释！！

​	线程组是一个可以**统一管理**的线程集合。默认情况下，创建的所有线程属于相同线程组。但是，也可能会建立其他的组。现在引入了更好的特性用于线程集合的操作，所以建议不要在自己的程序中使用线程组。

！！重点！！

​	

# 5.同步（非常重要）

​	同步的定性应该是一种好的情况。应该就是指竞争条件不会出现。

## 		1. 竞争条件(race condition)

​	要注意，race condition所描述的情况不是一定会发生的，而且发生了也不一定就会产生错误！但是一旦产生了错误，结果就是非常严重的（数据有误）



### 竞争条件详解

​	假定两个线程同时执行指令

​	accounts[to] += amount;		// accounts[to]  = accounts[to] + amount;

​	问题在于这不是原子操作。该指令可能被处理如下：

1. 将 accounts[to] 加载到寄存器

  2. 增加amount

  3. 将结果写回 accounts[to]。

     现在，假定第一个线程执行步骤1 和 2，然后，它被剥夺了运行权。假定第二个线程被唤醒并修改了 accounts数组中的同一项。然后，第一个线程被唤醒并完成其第三步。

     这样，**这一动作擦去了第二个线程所做的更新。于是，总金额不再正确**。(钱变少了！！)



​	出现这一错误的可能性是多少呢？这里通过将打印语句和更新余额的语句交织再一起执行，增加了发生这种情况的可能性。增加了发生这种情况的机会。

​	如果删除打印语句，错误的风险会降低一点。因为每个线程再再次睡眠之前所做的工作很少，调度器在计算过程中剥夺线程的运行权可能性很小。	但是，错误的风险并没有完全消失。如果在负载很重的机器上运行许多线程，那么即使删除了打印语句，程序依然会出错，而且还是无规律的，非常讨厌。

​	**真正的问题是transfer方法的执行过程中可能会被中断。如果能确保线程在失去控制之前方法运行完成，那么银行账户对象的状态永远不会出现错误**

## 2. 锁对象

​	用ReentrantLock 保护代码块的基本结构如下：

​	

```java
myLock.lock();	//a ReentrantLock objec
try{
    //critical section(临界区 对共享内容的访问代码)
}
finally{
    myLock.unlock();	//make sure the lock is unlocked even if an exception is thrown
}
```

​	这一结构确保任何时刻只有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。

！！警告！！！

​	把解锁操作括在finally子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放，否则，群体线程将永远被阻塞。

后面的注释没看懂是什么意思

### ReentrantLock

​	注意每一个Bank对象都有自己的ReentrantLock对象。如果两个线程试图访问同一个Bank对象，那么锁以串行方式提供服务。但是，如果两个线程访问不同的Bank对象，每一个线程得到不同的锁对象，两个线程都不会发生阻塞。本该如此，因为线程在操纵不同的Bank实例的时候，线程之间不会相互影响。

​	锁是可重入的，因为线程可以重复地获得已经持有的锁。锁保持一个持有计数(hold count)来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用使用相同的锁的方法。

​	例如，transfer方法调用 getTotalBanlance方法，这也会封锁bankLock对象，此时bankLock对象的持有计数为2。当gettotalBanlance方法退出的时候，持有计数变回1。当transfer方法退出的时候，持有计数变为0。线程释放锁。

（所以，如果我在代码中不在finally里面unlock逻辑上也是没问题的，但是为了避免出错还是要这样写）

##刚试过了是不行的，用完必须要释放才行。否则是会阻塞的##

## 3.  条件对象

​	这里面细节挺多的，具体要看着代码来讲解就行。

## 4. synchronized关键字

​	在前面一节中，介绍了如何使用Lock和Condition对象。在进一步深入之前，总结一下有关**锁和条件**的关键之处：

1. 锁用来保护代码片段，任何时刻只能由一个线程执行被保护的代码。
2. 锁可以管理试图进入被保护代码段的线程。
3. 锁可以拥有一个或多个相关的条件对象。（多重while循环，然后一层一个条件守着吗？？）
4. 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程。

Lock和Condition接口为程序员提供了高度的锁定控制。然而，大多数情况下，并不需要那样的控制，而且可以使用一种切入到Java语言内部的机制。从1.0版开始，Java中的每一个对象都有一个内部锁。如果一个方法用 synchronized 关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。

换句话说:

```java
public synchronized void method(){
    method body
}
等价于
public void method(){
	this.intrinsidock.lock();
    try{
    	method body
    }
    finally {this.intrinsidock.unlock();}
}
```

### 对静态方法使用

​	将静态方法声明为  synchronized  也是合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。例如，如果Bank类有一个静态同步的方法，那么当该方法被调用时，Bank.class对象的锁被锁住。因此，没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。**也就是说，本质上还是对象锁？？**

### 局限性

1.  不能中断一个正在试图获得锁的线程。
2. 试图获得锁时不能设定超时。
3. 每个锁仅有单一的条件，可能是不够的。（是的，有的场景可能需要多重条件来保证数据正确性）

### 建议

​	应该使用Lock和Condition对象还是同步方法？

1. 最好既不使用 Lock/Condition 也不使用 synchronized 关键字。在许多情况下你可以使用 java.util.concurrent 包中的一种机制，它会为你处理所有的加锁。 例如， 在 14.6 节，你会看到如何使用阻塞队列来同步完成一个共同任务的线程。还应当研究一下并行流，有关内容参见卷 n 第 1 章 。
2. 如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写的代码数量，减少出错的几率
3. 如果特别需要 Lock/Condition 结构提供的独有特性时，才使用 Lock/Condition。 



## 5. 同步阻塞

​	不太懂，代码版本有问题。

```java
package raceCondition.synchBlock;	//以后想改进的话到这个包里面去看
```



## 6.  监视器

### 	特性

 1. 监视器是只包含私有域的类。

 2. 每个监视器的类的对象有一个相关的锁。（本质上要搞懂对象锁这个概念）

    #我的理解就是，对象锁就是说要访问这个对象有关的所有内容时候，例如调用成员方法的时候，都必须要有有锁，否则阻塞住不能调用。

 3. 使用该锁对所有的方法进行加锁。换句话说，如果客户端调用 obj.method()，那么obj对象的锁是在方法调用开始时自动获得的，并且当方法返回时自动释放该锁。因为所有的欲都是私有的，这样的安排可以确保一个线程在对对象操作时，没有其他线程能访问该域。

 4. 该锁可以有任意多个相关条件。

后面的内容就有点看不懂了讲道理，也就是说java并没有把安全性放在很重要的位置吗？？所以说多线程的安全性由程序员来保证？？？

## 7. Volatile域

​	volatile 的中文翻译是：不稳定的，反复无常的

​	这个关键字用在实例域上，是一种不想为同步作出过多牺牲的折中方案，同步的效果由编译器和虚拟机保证。但是作者这里有点轻描淡写了，没有说的太清，下记住它的大概。

## 8. final变量

​	还有一种情况可以安全地访问一个共享域，即这个域声明为final。

```java
final Map<String,Double> accounts = new HashMap<>();
```

​	其他线程会在构造函数完成构造之后才看到这个accounts变量。

​	如果不使用final，就不能保证其他线程看到的是 accounts更新后的值，它们可能都只是看到null，而不是新构造的HashMap。

### 注意

​	**当然，对这个Map的操作并不是线程安全的，如果多个线程在读写这个Map，仍然需要进行同步。**

感觉我可以解释上面的情况，等等再后面解释一下吧。

### 解释

​	因为定义为 final 的变量必须要初始化才能使用，估计JVM用之前会去检查初始化没有，如果没有的话就阻塞当前线程，不给它用。（我猜测）



## 9. 原子性

​	说了一些花里胡哨的东西，主要是提供一些类来保证自增或自减操作的原子性。



## 10. 死锁（非常重要 必须深度理解）

锁和条件不能解决多线程中的所有问题。考虑下面的情况：

账户1： 200

账户2：300

线程1:	从账户1 转移 300 到账户2

线程2：	从账户2转移  400  到账户1

很显然，线程1和2都被阻塞了。因为账户1以及账户2的余额都不足以进行转账，两个线程都无法执行下去。

有可能会因为每一个线程要等待更多的钱款存入而导致所有线程被阻塞。这样的状态称为死锁。（Deadlock）

在这个程序中，死锁不会发生。每一次转账至多1000，因为有100个账户，而且总金额是100_000，在任意时刻，至少有一个账户的余额高于1000。从该账户取钱的线程可以继续运行。

**但是，如果修改run方法，把每次转账至多1000的限制去掉，死锁很快就会发生。**

​	讲 NACCOUNTS设为10。每次交易的金额上线设置为	2*INITIAL_BALANCE,然后运行该程序。程序将运行一段时间后就会挂起。		



考虑这样一个会发生死锁的例子：

​	账户1:	1990

​	所有其他账户：每一个 990

​	线程1：	从账户1转移 995 到账户 2

​	所有其他线程，从他们的账户转移 995 到另一个账户。

出了线程1，其他线程都被阻塞。因为他们的账户中没有足够的余额。

运行后出现如下状况：

​	账户1：	995

​	账户2：	1985

​	所有其他账户:		每个990

然后，线程1调用 signal。 signal方法随机选择一个线程为它解锁。假定它选择了线程3。该线程被唤醒，发现在它的账户里没有足够的金额，它再次调用 await。但是，线程1仍在运行，将随机地产生一个新的交易，例如：

​	线程1： 从账户1转移 997 到账户 2

现在，线程1也调用 await，所有的线程都被阻塞，系统死锁。

问题的起因在于调用 signal。它仅仅为一个线程解锁， 而且，它很可能选择一个不能继续运行的线程（在我们的例子中，线程 2 必须把钱从账户 2 中取出）。遗憾的是， Java 编程语言中没有任何东西可以避免或打破这种死锁现象。必须仔细设计程序， 以确保不会出现死锁 



## 线程局部变量（暂时看不到问题，先忽略）

​	在前面的内容中，我们讨论了在线程间共享变量的风险。有时可能要避免共享变量，使用 ThreadLocal辅助类为各个线程提供各自的实例。例如，SimpleDateFormat类不是线程安全的。

假设有一个静态变量：

​	

```java
	public static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
//如果两个线程都执行如下操作
String dateStamp = dateFormat.format(new Date());
```

结果可能很混乱，因为dateFormat使用的内部数据结构可能会被并发的访问所破坏。当然可以使用同步，但开销很大；或者也可以在需要时构造一个局部 SimpleDateFormat  对象，不过这也太浪费了。

讲道理，我试了一下也没发现有什么问题啊，所以这招还要学吗？？



## 还有一些相关内容先跳过了，我发现这同步问题太多了，不是一下子能搞定的



# 6. 阻塞队列

## 	前言：

​	现在，读者已经看到了形成Java并发程序设计基础的底层构件块，然而，对于实际编程来说，应该尽可能远离底层结构，使用由并发处理的专业人士实现的较高层级的结构要方便得多、要安全得多。

​	对于许多线程问题，可以通过使用一个或多个队列以优雅且安全的方式将其形式化。生产者线程向队列插入元素。消费者线程则取出它们。使用队列，可以安全地从一个线程向另一个线程传递数据。

​	例如，考虑银行转账程序，转账线程将转账指令对象插入一个队列中，而不是直接访问银行对象。另一个线程从队列中取出指令执行转账。只有该线程可以访问该该银行对象的内部。因此不需要同步。（当然，线程安全的队列类的实现者不能不考虑锁和条件，但是，那是他们的问题而不是你的问题）

​	当试图向队列添加元素而队列已满，或是想从队列移出元素而队列为空的时候，阻塞队列(blocking queue)导致线程阻塞。在协调多个线程之间的合作时，阻塞队列是一个有用的工具。工作者线程可以周期性地将中间结果存储在阻塞队列中。其他的工作者线程移出中间结果并进一步加以修改。队列会自动地平衡负载。如果第一个线程集运行得比第二个慢，第二个线程集在等待结果时会阻塞。如果第一个线程集运行得快，它将等待第二个队列集赶上来。

------

​	阻塞队列方法

```java

offer		添加一个元素并返回true		如果队列满，返回false,也就是说不一定会加进去
peek		返回队列的头元素			如果队列空，则返回null，也就是说不一定能拿到
poll		移出并返回队列的头元素		  如果队列空，则返回null，也就是说不一定能拿到
put			添加一个元素				 如果队列满，则阻塞	也就是一定要加进去，不然阻塞
take		移出并返回头元素			如果队列空，则阻塞	也就是说一定要拿到东西出来，不然阻塞
```



阻塞队列方法分为以下3类，这取决于当队列满或空时他们的响应方式。

1. 如果将队列当作线程管理工具来使用，将要用到put和take方法。
2. 当试图向满的队列中添加或从空的队列中移出元素时，add、remove、element操作抛出异常。
3. 当然，在一个多线程程序中，队列会在任何时候空或满，因此，一定要使用 offer、poll 和 peek 方法作为替代，这些方法如果不能完成任务，只是给出一个错误提示而不会抛出异常。



## 注释：

poll 和 peek 方法返回空来指示失败。因此，向这些队列中插入null值是非法的。

还要带有超时的 offer方法 和 poll方法的变体，例如，下面的调用:

```

```

