# 1.为什么需要泛型程序设计

​	Generic programming 意味着编写的代码可以被很多不同类型的对象所重用。

## 	类型参数的好处

​		使用了类型参数（type parameters）可以在编译期间就解决掉一些类型转换出错的问题

## 	谁想成为泛型程序员？

​		考虑这样的一个问题：irayList 类有一个方法 addAll 用来添加另一个集合的全部元素。 程序员可能想要将
​		ArrayList<Manager> 中的所有元素添加到 ArrayList<Employee> 中去。然而， 反过来就不行了。如果只能允				许前一个调用， 而不能允许后一个调用呢？ 	

​		解决方法是使用一个新的概念： 通配符类型(wildcard type)

# 2.定义简单泛型类

​	泛型类可以看作普通类的工厂

# 3.泛型方法	

``class ArrayAlg`
`{`
`public static <T> T getMiddle(T... a)`
`{`
`return a[a.length / 2];`
`}`
}` 

​	这样的话我们颗粒度就变小了，可以不用到类，具体到方法就行。毕竟一个类里面不是全部成员都需要用到类型参数的.

当调用一个泛型方法时
’
在方法名前的尖括号中放人具体的类型：
String middle = ArrayAlg.<String>getMiddle("]ohnM, "Q.n, "Public"); 



# 4.类型变量的限定

​	有时候，类或方法需要对类型变量加以约束。主要原因是确保你传入的类型符合某些约束。

例如，我们要要确保T所属的类有compareTo方法，我们可以这样写

public static <T extends Coiparab1e> T   min(T[]  a) . . . 

所以现在只有实现了Coiparab1e接口的类型才能传给这个min方法

## 一个类型变量或通配符可以有多个限定

​	public static <T extends Comparable& Serializable,V extends  Comparable> T min(T[] a)

### 限定类型用"&"分割，类型变量用 ","分隔



# 5.泛型代码和虚拟机

​	虚拟机没有泛型类型对象——所有对象都属于普通类。

## 	1.类型擦除

​		无论何时定义个泛型类型，都自动提供了一个相应的原始类型(raw type)。原始类型的名字就是删除类型参数后的泛型类型名。擦除(erased)类型变量，并替换为限定类型(无限定的变量用Object)

​	



![被擦除之后的类型](D:\我的文档\JAVA\java核心技术卷一\images\被擦除之后的类型.png)



而原始类型会用第一个限定的类型变量来替换。如果没有给定限定就用Object替换。

![在类型参数有限定的情况下被擦除之后的类型](D:\我的文档\JAVA\java核心技术卷一\images\在类型参数有限定的情况下被擦除之后的类型.png)



## 2.翻译泛型表达式

​	当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。

!在类型参数有限定的情况下被擦除之后的类型](D:\我的文档\JAVA\java核心技术卷一\images\在类型参数有限定的情况下被擦除之后的类型.png)

![编译器帮你做了强制类型转换](D:\我的文档\JAVA\java核心技术卷一\新建文件夹\编译器帮你做了强制类型转换.png)



# 一些想法

​	好像突然明白为什么泛型类可以不强制使用类型参数了，毕竟编译的时候会出现类型擦除的现象，你写了也没用了啊！

​	突然想到，如果对方法使用类型参数的话，那么用T还是？都没什么所谓，因为你每次调用的时候都是要指定一次的。但是如果对类使用类型参数的话就有大不同了，因为这决定你定义的变量在运行时能否改变自己的类型参数。

# 6.约束与局限性

## 	不能用基本类型实例化类型参数

​		原因是擦除之后，泛型类含有Object类型的域（那是不是可以说，这个类依赖于Object类型??），而Object不能存储double值。

