---
typora-root-url: images
---

# 1.面向对象程序设计概述

## 	

## 	类：

​		类是构造对象的模板或蓝图。

​		由类构造（construct）对象的过程称为创建类的实例(instance)。	

​		在java中编写的所有代码都位于某个类的内部。

​		封装(encapsulation,有时称为数据隐藏)

​			实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。

这里有句话就看不懂了：这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据。其他对象就不会知道或介意所发生的变化。

## 	对象：

要想使用OOP，一定要清楚对象的三个主要特性：

​	@对象的行为（behavior）：可以对对象施加哪些操作，或可以对对象施加哪些方法？

​	@对象的状态  (state) ：当施加那些方法时，对象如何响应？

​	@对象标识 (identity) ： 如何辨别具有相同行为与状态的不同对象？

同一个类的所有实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。

此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随时时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现。（如果不经过方法调用就可以改变对象状态，说明封装性遭到了破坏）

但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份（identity）。

@@ 所以说，靠句柄来识别对象是很不可可靠的，现在大量使用的东西叫匿名对象，这些家伙都是无名氏，那我们怎样标识这些东西呢？用的好像就是hashcode?

@@应该不能简单的这样说，反正识别对象靠@xxxx就行了，这个是不可能重复的，来标识唯一的一个对象。

## 识别类：

​	经验之谈，名词作为属性，动词作为方法。

## 

## 类之间的关系：

### 依赖

### 聚合

### 继承	

难点在于？依赖和聚合的区别是什么？

​	如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。

​	而聚合关系意味着类A的对象包含类B的对象。

但是我们经常都可以在代码中看到我们对一个类可能又是依赖又是聚合的。一个类里面放了其他类型的句柄，然后通过注入实例化。然后又在这个类的方法里面用了其他类型的方法，这不就是又是依赖又是聚合了吗？所以这两个概念是可能会重合的，而不是完全没有交集的，之前的理解不够深，没有到这个点。

通常来说单纯聚合的情况很少，绝大多数是以下这两种情况：

​	依赖：没有作为成员，但是在方法中需要用到这种类型的参数，称之为依赖。一种单纯的依赖这种类型。

​	依赖+聚合：作为成员而且还在方法中用了，这就是最常见的情况了。



# 2. 使用预定义类

​	在java中，没有类就无法做任何事情。

​	然而，并不是所有的类都具有面向对象特征。

​	例如	Math类竟然全部都是静态方法！而且也没有实例域(但是有静态常量 static final )！我感觉工具类应该都是这种设计方法吧.

​	**所有的java对象都存储在堆中。当一个对象包含另一个对象变量时，这个变量依然包含着指向另一个堆对象的指针**。

## 		Java类库中的LocalDate类

​			时间是用距离一个固定时间点的毫秒数(可正可负)表示的，这个点就是所谓的纪元(epoch)

​			纪元是UTC时间 1970年1月1日 00:00:00

​			UTC： Coordinated Universal Time的缩写

​			GMT：Greenwich Mean Time 格林威治时间

​		上面着两种时间都是一种具有实践意义的科学标准时间

Date类：用来表示时间点

LocalDate类：用来表示大家熟悉的日历表示法的类。



# 	3.用户自定义类

​		重点：如何设计复杂应用程序所需要的各种主力类(workhorse class),通常，这些类没有main方法，却有自己的实例域和实例方法

​		一个完整的程序应该是将若干类组合在一起，其中只有一个类有main方法.

​	话说 unix的 “make”工具到底是拿来干嘛的，我发现经常有用到，但是不知道是什么来的

## 		隐式参数与显示参数

​	隐式参数也就是所谓的this，我看有一种用法是把this当参数传递进去。我突然又联想到订阅者模式了，通过xxx(this)这种方法就可以把订阅者加进去了！

​	显示参数就不多说了，经常都会用的东西。传基本类型还好，基本就是直接用，如果传类型进行就复杂了，分分钟各种调用烦死人。

## 封装的优点

​	封装我们经常都干（也就是所谓的把实例域定义为私有，然后写上公有的get set方法)，但是这样做到底有什么好处呢？

​	1.首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。例如，如果将存储名字的域改为：

​	

```java
String firstName;
String last Name
//那么getName方法可以改为返回
firstName + " " + lastName  
```



对于这点改变，程序的其他部分完全不可见

​	@@但是奇怪的是，你setName的方法不是要改变吗 所以也并没有完全消除影响。

2. 当然，为了进行新旧数据表示之间的转换，get方法和set方法有可能需要做许多工作。但是，这将为我们带来第二个好处：set方法可以执行错误检查，然而直接对域进行赋值将不会进行这些处理。

   例如，setSalary方法可以检查薪金是否小于0.

   ​	@@一开始我想这样反驳：那我在执行set方法前检查一下不就好了。效果一样啊！但是紧接着我有考虑到：假设这set方法被执行的次数超过一次，那么它这样设计就有优势，**假设被执行很多次，那这样设计的价值就很大了**。



### 警告：

​	注意不要编写返回引用可变对象的get方法。在Employee类中就违反了这个设计原则，其中的getHireDay 方法返回了一个Date类对象：

```java
class Employee{
    private Date hireDay;
    public Date getHireDay(){
        return hireDay; //Bad
	}
}
```

LocalDate没有set方法，但是Date类有一个set方法setTime(),可以在这里设置毫秒数

Date对象是可变的，这一点就破坏了封装性！

```java
Employee harry = . .
Date d = harry.getHireDay();
double tenYearsInMilliSeconds = 10 * 365.25 * 24 * 60 * 60 * 1000;
d.setTime(d.getTime() - (long) tenYearsInMilliSeconds) ;
// let's give Harry ten years of added seniority
```

出错的原因很微妙，d 和 garry.hireDay引用同一个对象。对 d 调用set方法就可以自动地改变这个雇员对象的私有状态。

![返回可变数据域的引用](/返回可变数据域的引用.png)

如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone）.@@**我觉得应该是说，如果需要返回一个可变对象的拷贝，也就是不希望修改原有的对象**@@。对象**clone是指存放在另一个位置上的对象副本**。



```java
class Employee{
    public Date getHireDay(){
        return (Date)hireDay.clone();	//ok
    }
}
```



凭经验可知，如果需要返回一个可变数据域的拷贝，就应该使用clone.





# 8.类路径

​	在前面已经看到，类存储在文件系统的子目录下。类的路径必须于包名匹配。

​	另外，类文件也可以存储在JAR（java归档）文件中。在一个JAR文件中，可以包含多个压缩形式的类文件和子目录，这样既可以节省又可以改善性能。在程序中用到第三方(third-party)的库文件时，通过会给出一个或多个需要包含的JAR文件。JDK也提供了许多的JAR文件。例如，在 jre/lib/rt.jar中包含数千个类库文件。有关创建JAR文件的详细内容将在第9章中讨论。	

## 	为了使类能够被多个程序共享，需要做到下面几点：

  1. 把类放到一个目录中，例如 /home/user/classdir。需要注意，这个目录是包树状结构的根目录。如果希望将com.lwx.corejava.Employee类添加到其中，这个Employee.class类文件就必须位于子目录	/home/user/classdir/com/lwx/corejava中。

  2. 将JAR文件放在一个目录中，例如:	/home/user/archives。

  3. 设置类路径（class path）。**类路径是所有包含类文件的路径的集合**

     在unix环境下，类路径中的不同项目之间采用冒号(:) 分割：

     **/home/user/classdir :	.	:	/home/user/archives/archive.jar**

     而在Windows环境中，则以分号(;)分隔：

     c:\classdir;	.	;	c:\archives\archive.jar

     在上述两种情况中，句号(.) 表示当前目录。

     类路径包括（只列举unix）：

     根目录	/home/user/classdir

     当前目录：	（.）

     JAR文件	/home/user/archives/archive.jar

从Java SE6 开始，可以在JAR文件目录中指定通配符，如下：

/home/user/classdir:	.	:	/home/user/rachives/'*'

或者

c:\classdir;	.	;	c:\archives\*

但在UNIX中，禁止使用	*	以防止shell命令进一步拓展。（啥子意思？？）

在archives中的所有JAR文件（但不包括.class文件）都包含在类路径中。

​	由于运行时库文件(rt.jar 和 在 jre/lib 与 jre/lib/ext 目录下的一些其他的JAR文件) 会被自动地搜索，所以不必将他们显式地列在类路径中。（当然你列了也可以）

## !!警告!!

​	**javac编译器**总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有	"."	目录的时候才查看当前目录。如果没有设置类路径，那也不会产生什么问题，默认的类路径包含	"." 目录。然而如果设置了类路径却忘记了包含 "."  目录，则程序仍然可以通过编译，但不能运行。(因为少了当前目录下的那些内容)



## 类路径所列出的目录和JAR是搜索类的起始点

​	下面看一个类路径示例：

​	/home/user/classdir :  .  :  /home/user/archives/archive.jar

假定虚拟机要搜寻 com.horstmann.corejava.Employee类文件。

它首先要查看存储在 jre/lib 和 /jre/lib/ext目录下的JAR中所存放的系统类文件。（每个java程序都会去看的），显然，在那里找不到相应的类文件，然后再查看类路径。然后查找以下文件:

/home/user/classdir/com/horstmann/corejava/Employee.class

com/horstmann/corejava/Employee.class

com/horstmann/corejava/Employee.class  inside  /home/user/archives/archive.jar

编译器定位文件要比虚拟机复杂得多。如果引用了一个类，而没有指出这个类所在的包，那么编译器将首先查找包含这个类的包，并询查所有的import指令，确定其中是否包含了被引用的类。例如，假定源文件包含指令：

import java.util.*;
import com.horstmann.corejava.*; 

并且源代码引用了Employee类，编译器将试图查找java.lang.Employee(因为java.lang包被默认导入) ,  java.util.Employee	,  com.horstmann.corejava.Employee 和当前包中的  Employee。

对这个类路径的所有位置中所列出的每一个类进行逐一查看。如果找到了一个以上的类，就会产生编译错误。

（因为类必须是唯一的，而import语句的次序却无关紧要）	

编译器的任务不止这些，它还要查找源文件（Source files）是否比类文件新。如果是这样的话，那么源文件就会被自动地重新编译（实现的方法感觉可以是设置一个flag，有修改过就设置为true，默认为false，然后被编译过后全部重置为false）。在前面已经知道，仅可以导入**其他包中的公有类**。一个源文件只能包含一个公有类，并且文件名必须与公有类匹配。因此，编译器很容易定位公有类所在的源文件。当然，也可以**从当前包中导入非公有类**。这些类有可能定义在与类名不同的源文件中。如果从当前包中导入一个类，编译器就要搜索当前包中的所有源文件，以便确定哪个源文件定义了这个类。



## 设置类路径（重点！）

​	最好采用	-classpath（或 -cp）选项指定类路径：

​	java -classpath /home/user/dassdir:.:/home/user/archives/archive.jar HyProg 

​	或者

​	java -classpath c:\classdir;.;c:\archives\archive.jar MyProg 

整个指令应该书写在一行中。将这样一个长的命令行放在一个shell脚本或一个批处理文件中是一个不错的注意（这也是我后面要搞的）



## !!警告1!!

有人建议将CLASSPATH环境变量设置为永久不变的值，这是不可取的。人们有可能会忘记全局设置，因此，当使用的类没有正确地加载进来时，会感到很奇怪一个应该受到it责的示例是 Windows 中 Apple 的 QuickTime 安装程序。 它进行了全局设置， CLASSPATH 指向一个所需要的 JAR 文件， 但并没有在类路径上包含当前路径。 因此， 当程序编译后却不能运行时， 众多的 Java 程序员花费了很多精力去解决这个问题。 

## 解释：

​	因为java编译器无论怎样都会去编译当前目录下的内容，但是java虚拟机在设置了类路径的情况不会去找，除非你把当前目录包含在类路径中。（这是否是java设计的一个缺陷呢？按道理也因为要默认在当前目录下去找吧）



## !!警告2!!

​	有人建议绕开类路径，将所有的文件放在 jre/lib/ext路径。这是一个极坏的注意。其原因有两个：

​	1.当手工地加载其他的类文件时，如果将它们存放在拓展路径上，则不能正常地工作（**不知道什么意思**）

​	2.此外，程序员经常会忘记3个月前存放文件的位置。当类加载器忽略了曾经仔细设计的类路径时，程序员会毫无头绪地在头文件中查找。事实上，加载的是拓展路径上已长时间遗忘的类。

​	





