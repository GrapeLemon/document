# 1.为什么需要泛型程序设计

​	Generic programming 意味着编写的代码可以被很多不同类型的对象所重用。

## 	类型参数的好处

​		使用了类型参数（type parameters）可以在编译期间就解决掉一些类型转换出错的问题

## 	谁想成为泛型程序员？

​		考虑这样的一个问题：irayList 类有一个方法 addAll 用来添加另一个集合的全部元素。 程序员可能想要将
​		ArrayList<Manager> 中的所有元素添加到 ArrayList<Employee> 中去。然而， 反过来就不行了。如果只能允				许前一个调用， 而不能允许后一个调用呢？ 	

​		解决方法是使用一个新的概念： 通配符类型(wildcard type)

# 2.定义简单泛型类

​	泛型类可以看作普通类的工厂

# 3.泛型方法	

``class ArrayAlg`
`{`
`public static <T> T getMiddle(T... a)`
`{`
`return a[a.length / 2];`
`}`
}` 

​	这样的话我们颗粒度就变小了，可以不用到类，具体到方法就行。毕竟一个类里面不是全部成员都需要用到类型参数的.

当调用一个泛型方法时
’
在方法名前的尖括号中放人具体的类型：
String middle = ArrayAlg.<String>getMiddle("]ohnM, "Q.n, "Public"); 



# 4.类型变量的限定

​	有时候，类或方法需要对类型变量加以约束。主要原因是确保你传入的类型符合某些约束。

例如，我们要要确保T所属的类有compareTo方法，我们可以这样写

public static <T extends Coiparab1e> T   min(T[]  a) . . . 

所以现在只有实现了Coiparab1e接口的类型才能传给这个min方法

## 一个类型变量或通配符可以有多个限定

​	public static <T extends Comparable& Serializable,V extends  Comparable> T min(T[] a)

### 限定类型用"&"分割，类型变量用 ","分隔



# 5.泛型代码和虚拟机

​	虚拟机没有泛型类型对象——所有对象都属于普通类。

## 	1.类型擦除

​		无论何时定义个泛型类型，都自动提供了一个相应的原始类型(raw type)。原始类型的名字就是删除类型参数后的泛型类型名。擦除(erased)类型变量，并替换为限定类型(无限定的变量用Object)

​	



![被擦除之后的类型](D:\我的文档\JAVA\java核心技术卷一\images\被擦除之后的类型.png)



而原始类型会用第一个限定的类型变量来替换。如果没有给定限定就用Object替换。

![在类型参数有限定的情况下被擦除之后的类型](D:\我的文档\JAVA\java核心技术卷一\images\在类型参数有限定的情况下被擦除之后的类型.png)



## 2.翻译泛型表达式

​	当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。

!在类型参数有限定的情况下被擦除之后的类型](D:\我的文档\JAVA\java核心技术卷一\images\在类型参数有限定的情况下被擦除之后的类型.png)

![编译器帮你做了强制类型转换](D:\我的文档\JAVA\java核心技术卷一\images\编译器帮你做了强制类型转换.png)

也就是说，编译器通过类型参数记住了他要做的事情    ->  帮你进行强制类型转换

所以说泛型的使用，并没有改变本来把什么都当Object给放进去，然后拿出来的时候强转的这种操作。但是可以让编译器多了一层检查，尽可能的保证了类型安全。

# 6.约束与局限性

## 	1.		不能用基本类型实例化类型参数

​		原因是擦除之后，泛型类含有Object类型的域（那是不是可以说，这个类依赖于Object类型??），而Object不能存储double值。

## 2.		运行时类型查询只适用于原始类型

​	什么叫运行时类型查询呢？ ->   a instanceof Pair 

![运行时类型查询只适用于原始类型](D:\我的文档\JAVA\java核心技术卷一\新建文件夹\运行时类型查询只适用于原始类型.png)

## 3.		getClass方法总是会返回原始类型

![getClass方法总是会返回原始类型的class](D:\我的文档\JAVA\java核心技术卷一\新建文件夹\getClass方法总是会返回原始类型的class.png)

## 3.1.		不能创建参数化类型的数组（关键是@为什么@不能）

​	不能实例化参数化类型的数组，例如:

​		Pair<String>[] table = new Pair<String>[10]; // Error 

这有什么问题呢？擦除之后，table的类型是Pair[]。可以把它转换为Object[]

​		Object[] objarray = table; 

数组会记住它的元素类型，如果试图存储其他类型的元素，就会抛出一个ArrayStoreException异常.

​		objarray[0] = "Hello"; // Error component type is Pair 

不过对于泛型类型，擦除会使这种机制无效。以下赋值：

​		objarray[0] = new Pair< Employee>0； //上面的类型参数是String

能够通过数组存储检查，不过仍会导致一个类型错误。出于这个原因，不允许创建参数化类型的数组。

需要说明的是，只是不允许创建这些数组，而声明类型为Pair<String>[] 的变量仍是合法的。不过不能用 

new Pair<String>[10]	初始化这个变量。

​	@注释@：可以声明通配符类型的数组，然后进行类型转换：

​	Pair<String>[] table = (Pair<String>[]) new Pair<?>[10]; 

​	结果将是不安全的。如果在table[0]中存储一个Pair<Employee>,然后对table[0].getFirst()调用一个String方法，会得到一个ClassCastException异常。

​	@提示@:  如果需要收集参数化类型的对象，只有一种安全而有效的方法：使用ArrayList:ArrayList<Pair<String>>

​	讲道理，我看不出这个是什么意思,泛型里面又套泛型，牛P了

4.		Varargs警告

​	我们来考虑一个问题：向参数个数可变的方法传递一个泛型类型的实例。

​	考虑下面这个简单的方法，它的参数个数是可变的：

​	public static <T> void addAll(Collections coll, T... ts)
​	{
​		for (t : ts) coll.add(t)；
​	} 		

​	实际上参数ts是一个数组，包含提供的所有实参

​	现在考虑以下调用：
​	Collection<Pair<String» table = . . .;
​	Pair<String> pairl = . . .;
​	Pair<String> pair2 = . .
​	addAll (table, pairl, pair2); 	

​	为了调用在这个方法，Java虚拟机必须建立一个Pair<String>数组，不过，对于这种情况，规则有所放松，你只会得到一个警告，而不是错误。

​	可以采用两种方法来抑制这个警告

​	一种方法是为包含 addAll 调用的方法增加注解 @SuppressWamings("unchecked") 

​	另一种方法是在java7中，用@SafeVarargs

​	@SafeVarargs
​	public static <T> void addAll(Collection<T> coll, T... ts) 	

​	现在就可以提供泛型类型来调用这个方法了。对于只需要读取参数数组元素的所有方法，都可以使用这个注解，这仅限于最常见的用例。（也就是说别滥用的意思？？）

@注释@: 可以使用	@SafeVarargs标注来消除创建泛型数组的有关限制，方法如下：

​	@SafeVarargs		//我觉得这个注解的含义可以理解为安全的参数数组变量(元素)

​	static <E> E[] array (E ...array) {	return array;	}

​	现在可以调用：

​	Pair<String>[] table = array(pair1, pair2 );

​	这看起来很方便，不过隐藏着危险，以下代码：

​	Object[] objarray = table;

​	objarray[0] = new Pair<Employee>();	//就是把第一个元素改掉了原来的是<String>改成了<Employee>

​	能顺利运行而不会出现ArrayStoreException异常(因为数组存储只会检查擦除的类型，也就是只会检查是不是Pair)，

​	但在处理table[0]的时候你会在别处得到一个异常。（因为这时候你会当成String用，但是实际上里面是Employee）



## 不能实例化类型变量

 	不能使用像new T(...), new T[...] 或者 T.class 这样的表达式中的类型变量。 例如，下面的Pair<T>构造器就是非法的：

​	public Pair() { first = new T(); second = new T(); } // Error 

​	类型擦除将T改变成Object，而且，本意肯定不希望调用new Object()。（而是希望调用你传入的类型参数）。在JAVA8之后，最好的解办法是让调用者提供一个构造器表达式。例如

​	Pair<String> p = Pair.makePair(String :: new);

​	makePair方法接收一个Supplier<T>，这是一个函数式接口，表示一个无参数而且返回类型为T的函数:

​	public static <T> Pair<T> makePair(Supplier<T> constr)



​	

























# @@@@一些想法

​	好像突然明白为什么泛型类可以不强制使用类型参数了，毕竟编译的时候会出现类型擦除的现象，你写了也没用了啊！

​	突然想到，如果对方法使用类型参数的话，那么用T还是？都没什么所谓，因为你每次调用的时候都是要指定一次的。但是如果对类使用类型参数的话就有大不同了，因为这决定你定义的变量在运行时能否改变自己的类型参数。

