# 1.为什么需要IOC？

​	其实我们自己去new一下对象不就好了吗？自己控制而且也不会说太麻烦。

作者是这样说的：我们自己每次用到什么依赖对象都要主动地去获取，这是否真的必要呢？我们最终要做的，其实就是直接调用依赖对象所提供的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。

**其实也是，如果一个项目里面要多处使用到这个类的话，每一个要用类的地方都new一遍，想想也觉得很麻烦，Spring的这种方式相当于把Bean搞成全局对象来为我们提供服务了**

所以首先反转的第一步，就是你从原来的 亲历亲为 变成了现在的 享受服务。这不是很爽吗哈哈



![1564800017603](D:\我的文档\JAVA\框架\Spring解密\images\IoC的角色.png)

通常情况下，被注入对象会直接依赖于被依赖对象。但是，再IoC的场景中，二者之间通过IoC Service Provider来打交道，**所有的被注入对象和依赖对象现在由IoC Service Providert统一管理**。 所以，被注入对象需要什么，直接跟 ISP招呼一声，后者就会把相应的被依赖对象注入到依赖对象中。从而达到IOC为被注入对象服务的目的。

所以说，所谓的控制反转，**是指创建对象的控制权从被注入对象转移到了IOC服务提供者中**



![1564800443961](D:\我的文档\JAVA\框架\Spring解密\images\使用Ioc前后的差别.png)



自己去拿自己穿上（自己new 而且自己赋值给自己定义的引用）

别人去拿给你穿上（自己只需要定义一个该类型的引用，**然后告诉spring我要这个**，在以后一切都会准备好）

**所以现在的关键问题是如何告诉spirng 我要这个 以及 我要怎样的对象，我现在缺乏的就是这方面的知识。**导致闹出了很多似是而非的错误。



# 2.注入

这个章节的核心是 通知服务员的方式。

@@ 我感觉我之前总是觉得spring只是做一下注入，现在发现自己对spring的了解程度是多么的浅薄啊！！路漫漫其修远兮，吾将上下而求索

## 构造方法注入

​	顾名思义，构造方法注入就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表，让外部（通常是Ioc容器）知道它需要哪些依赖对象。下面是一个例子

![1564801661329](D:\我的文档\JAVA\框架\Spring解密\images\code1)



构造方法注入就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表，进而为其注入相应的对象。**同一个对象是不可能被构造两次的，因此，被注入对象的构造乃至其整个声明周期，应该是由IOC服务提供者来管理的**

**构造方式注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用**



## setter方法注入

​	**sette方法注入虽不像构造方法注入那样，让对象的构造完成后即可使用，但相对宽松一些，可以在对象构造完成后再注入。**

## 接口注入（不推荐使用）

​	不推荐使用，了解前面两种即可



## 构造方法和setter方法注入的比较

重点说一下构造方法注入的缺点：	

1.当依赖的对象比较多的时候，构造方法的参数列表比较长。

2.而通过反射构造对象的时候，对相同类型的参数处理会比较困难。维护和使用上也比较麻烦。

3.而且在java中，构造方法无法被继承，无法设置默认值（不行吗？讲道理这个就不太清楚了）。对于非必要的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。



所以说我得出这个结论：**除非场景是 要对象创建的时候就完全准备就绪，否则的话就用set注入就好**，可以省去不少麻烦。

# 3.IOC的附加值

​	这里要说的其实就是，IOC究竟还能给我们带来什么别的好处？

回到作者的例子，在使用IoC重构之前，如果没有其他需求或者变动，不光看起来，用起来也是没问题的。（我之前好像就是持有这样的观点。。。）**但是，当系统中需要追加逻辑以处理另一家新闻社的新闻来源时，问题就来了**

