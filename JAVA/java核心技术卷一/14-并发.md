# 引言：

​	读者可能已经很熟悉操作系统中的多任务(multitasking): 在同一刻运行多个程序的能力。例如，在编辑或者下载邮件的**同时**可以打印文件。今天，人们很可能有单台拥有多个CPU的计算机。但是，并发执行的进程数目并不是由CPU数目制约的。（也就是说，并不是说都多少个CPU就只能并发执行多少个进程的意思）操作系统将CPU的时间片分配给每一个进程，给人并行处理的感觉。

​	多线程在较低的层次上拓展了多任务的概念：一个程序同时执行多个任务。通常，每一个任务(Task)称为一个线程(thread)，它是线程控制的简称。	可以同时运行一个以上线程的程序称为多线程程序。(multithreaded)，很显然，服务器程序基本都是多线程程序，所以多线程对于服务器开发来说非常重要。

​	那么，多进程和多线程有哪些区别呢？本质的区别在于每个进程都拥有自己的一整套变量，而线程则共享数据！这种行为是有风险的。然而，共享变量使线程之间的通信比进程之间的通信更有效、更容易。此外，在有些操作系统中，与进程相比较，线程更“轻量级”，创建、撤销一个线程比启动新进程的开销要小的多。

​	在实际应用中，多线程非常有用。例如，一个浏览器可以同时下载几幅图片。一个Web服务器需要同时处理几个并发的请求。图形用户界面(GUI)程序用一个独立的线程从宿主操作系统环境中搜集用户界面的事件。本章将介绍如何为Java应用程序变价多线程能力。

# 1.什么是线程？

## 	sleep

​	调用	 Thread.sleep不会创建一个新线程，sleep是Thread类的静态方法，用于暂停当前线程的活动。

​	sleep方法可以抛出一个	IntermptedException 异常。



## 	使用线程给其他任务提供机会

​		如果需要执行一个比较耗时的任务(统计，IO这些什么的，应当并发地运行任务。

​		下面是在一个单独的线程中执行一个任务的简单过程：

​		将任务代码移到实现了Runnable接口的类的run方法中。这个接口非常简单。只有一个方法(函数式接口)

​	

```java
public interface Runnable{
    void run();
}
```

由于Runnable是一个函数式接口，可以用lambda比倒是建立一个实例：

```java
Runnable r = () -> {task code};
```

由Runnable创建一个Thread对象

```java
Thread t = new Thread(r);
```

启动线程:

```java
t.start();
```

不过，这种方法已不在推荐。应该将要并行运行的任务与运行机制解耦合。如果有很多任务，要为每个任务创建一个独立的线程所付出的代价太大了。可以使用**线程池**来解决这个问题。

### !!警告!!

​	不要调用Thread类或Runnable对象的run方法。（感觉我好像经常就这样...有点想当然了）直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。（这句话是什么意思？？看不懂）应该调用Thread.start方法，这个方法将创建一个执行run方法的新线程。

懂了，也就是说直接调用run就好像方法调用，还是当前线程在干活，那也就没有用到多线程了。



# 2.中断线程

​	当线程的run方法执行方法体中最后一条语句后，并经由执行return语句返回时，或者出现了在方法中没有捕获的异常时，线程将终止。

​	在java的早期版本中，还有一个stop方法，其他线程可以调用它终止。在java的早期版本中，还有一个stop方法，其他线程可以调用它终止线程。但是，这个方法已经被弃用了。后面将讨论为何弃用。

​	没有可以强制线程终止的方法。然而，interrupt方法可以用来请求终止线程。

​	当对一个线程调用interrupt方法时，线程的中断状态将被修改。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断（注意和终止的区别）。

​	要想弄清楚中断状态的的情况，首先调用静态的 Thread.currentThread方法获得当前线程，然后调用

isInterrupted方法：

​	

```
while (!Thread.currentThread().islnterrupted() && more work to do)
{
do more work
}
```

但是，如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方。当在一个被阻塞的线程（调用sleep或者wait）上调用interrupt方法时，阻塞调用将会被Interrupted Exception 异常中断 。存在不能被中断的阻塞 I/O 调用， 应该考虑选择可中断的调用。有关细节请参看卷 n 的第 1 章和第 3 章。）

​	没有任何语言 方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中断。但是，更普遍的情况是，线程将简单地将中断作为一个终止的请求。这种线程的run方法具有如下形式:

```java
Runnable r = () -> {
try
{
	while (!Thread.currentThread().islnterrupted() && more work to do)
	{
		do more work
	}
}
catch(InterruptedException e)
{
// thread was interrupted during sleep or wait
}
finally
{
	cleanup, if required
}
// exiting the run method terminates the thread 因为执行完了！！
}；
```

如果在每次工作迭代之后都调用sleep方法(或者其他的可中断方法)，isInterrupted检测既没有必要也没有用处。如果在中断状态被修改时调用sleep方法，它不会休眠。相反，它将清除这一状态(!)并抛出IntemiptedException 。因此，如果难点循环调用sleep，不会检测中断状态。相反，要如下所示捕获 InterruptedException 异常： 

```java
Runnable r = 0 -> {
try
{
	while { more work to do)
	{
		do more work
		Thread,sleep(delay);
	}
}
catch(InterruptedException e)
{
	// thread was interrupted during sleep
}
finally
{
	cleanup,if required
}
	// exiting the run method terminates the thread
}；
```

@@注释@@​	

有两个非常类似的方法，interrupted 和 islnterrupted。Interrupted 方法 是一个静态方法，它检测当前的线程是否被中断。而且，调用interrupted 方法会清除改线程的中断状态。另一方面，islnterrupted是一个实例方法。可用来检测是否有线程被中断。调用这个方法不会改变中断状态。



@@在很多发布的代码中会发现InterruptedException 异常被抑制在很低的层次，像这样:

```java
void mySubTaskO
{
try { sleep(delay); }
catch (InterruptedException e) {} // Don't ignore!
}
```

不要这样做！如果不认为在catch子句中做这一处理有什么好处的话，仍然有两种合理的选择：

​	在catch子句中调用Thread.currentThread().interrupt()  来设置中断状态。于是，调用者可以对其进行检测。

```java

```

或者，更好的选择是，用throws InterruptedException标记你的方法，不采用 try语句块捕获异常。于是，调用者(或者，最终的run方法)可以捕获这一异常。

​	这个调用者就有点诡异了。 就是从哪个方法里面写了调用这些方法，就称之为调用者吧，有点绕。

```java
void mySubTask() throws InterruptedException{
    ...
    sleep(delay);
    ...
}
```

```java
void interrupt()
//向线程发送中断请求。线程的中断状态将被设置为true。如果目前该线程被一个sleep调用阻塞，那么InterruptedException异常被抛出
    
static boolean interrupted()
//测试当前线程(即正在执行这一命令的线程)是否被中断。注意，这是一个静态方法。这一调用回产生副作用————它将当前线程的中断状态重置为false
    
static Thread currentThread()
//返回代表当前执行线程的Thread对象。
```

